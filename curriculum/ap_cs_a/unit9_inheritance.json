{
  "title": "Unit 9: Inheritance",
  "description": "This unit explores inheritance, a fundamental concept in object-oriented programming.",
  "topics": {
    "inheritance_basics": {
      "title": "Inheritance Basics",
      "keywords": ["inheritance", "extends", "superclass", "subclass", "parent", "child"],
      "content": "## Inheritance in Java\n\n### Definition:\nInheritance is a fundamental concept in object-oriented programming that allows a class (subclass) to inherit attributes and methods from another class (superclass).\n\n### Syntax:\nIn Java, inheritance is implemented using the `extends` keyword:\n\n```java\n// Superclass (Parent class)\npublic class Animal {\n    private String name;\n    \n    public Animal(String name) {\n        this.name = name;\n    }\n    \n    public void eat() {\n        System.out.println(name + \" is eating.\");\n    }\n    \n    public String getName() {\n        return name;\n    }\n}\n\n// Subclass (Child class)\npublic class Dog extends Animal {\n    private String breed;\n    \n    public Dog(String name, String breed) {\n        super(name);  // Call the superclass constructor\n        this.breed = breed;\n    }\n    \n    public void bark() {\n        System.out.println(getName() + \" is barking.\");\n    }\n    \n    public String getBreed() {\n        return breed;\n    }\n}\n```\n\n### Key Concepts:\n\n1. **Superclass (parent class)**: \n   - The class being inherited from (Animal in the example)\n   - Contains common attributes and behaviors\n\n2. **Subclass (child class)**: \n   - The class that inherits from the superclass (Dog in the example)\n   - Gains all non-private members of the superclass\n   - Can add its own unique attributes and methods\n\n3. **'extends' keyword**: \n   - Used to establish the inheritance relationship\n   - Syntax: `public class Subclass extends Superclass { }`\n\n4. **'super' keyword**: \n   - Used to call the superclass constructor or methods\n   - Must be the first statement in a subclass constructor\n\n5. **Method overriding**: \n   - Redefining a method in a subclass that was defined in the superclass\n   - Enables specialized behavior in subclasses\n\n### Benefits of Inheritance:\n\n* **Code reuse**: \n  - Subclasses inherit attributes and methods from superclasses\n  - Reduces redundancy and promotes DRY (Don't Repeat Yourself) principle\n\n* **Hierarchical organization**: \n  - Creates a logical structure for classes\n  - Makes code more organized and easier to understand\n\n* **Polymorphism**: \n  - Enables objects of different subclasses to be treated as objects of the superclass\n  - Increases flexibility in code design\n\n### Practice Exercise:\n\nCreate a `Cat` class that inherits from the `Animal` class. Add a method called `meow()` that prints the cat's name followed by \" is meowing.\" Test your implementation by creating a Cat object and calling its methods.\n\n### Common Mistakes to Avoid:\n\n1. Forgetting to call the superclass constructor when required\n2. Trying to inherit from multiple classes (Java doesn't support multiple inheritance for classes)\n3. Attempting to override private methods (not possible in Java)\n4. Forgetting that constructors are not inherited"
    },
    "method_overriding": {
      "title": "Method Overriding",
      "keywords": ["override", "overriding", "@Override", "method override"],
      "content": "## Method Overriding in Java\n\n### Definition:\nMethod overriding is a feature in Java that allows a subclass to provide a specific implementation of a method that is already defined in its superclass.\n\n### Rules for Method Overriding:\n\n1. **Same Method Signature**:\n   - The method in the subclass must have the same name as in the superclass\n   - The method must have the same parameter list (number, type, and order)\n\n2. **Return Type Compatibility**:\n   - The return type must be the same or a subtype of the return type in the superclass\n   - This is called covariant return types\n\n3. **Access Modifiers**:\n   - The access level cannot be more restrictive than the overridden method\n   - Example: If superclass method is `protected`, subclass method can be `protected` or `public`, but not `private`\n\n4. **Exception Handling**:\n   - The method cannot throw broader checked exceptions than the superclass method\n   - Can throw fewer or narrower checked exceptions, or any unchecked exception\n\n### Example of Method Overriding:\n\n```java\n// Superclass\npublic class Animal {\n    public void makeSound() {\n        System.out.println(\"The animal makes a sound\");\n    }\n}\n\n// Subclass\npublic class Dog extends Animal {\n    @Override  // This annotation is optional but recommended\n    public void makeSound() {\n        System.out.println(\"The dog barks\");\n    }\n}\n```\n\n### The @Override Annotation:\n\n* **Purpose**: Indicates that a method is intended to override a superclass method\n* **Benefits**:\n  - Helps the compiler verify that you are actually overriding a method\n  - If the superclass method doesn't exist or has a different signature, the compiler will show an error\n  - Makes code more readable by clearly indicating overridden methods\n* **Usage**: Place it directly above the method declaration\n\n### Dynamic Method Dispatch:\n\nWhen a method is overridden, Java determines which method to call based on the actual object type, not the reference type:\n\n```java\nAnimal myPet = new Dog();  // Animal reference, Dog object\nmyPet.makeSound();       // Calls Dog's makeSound() method, not Animal's\n```\n\nThis behavior is known as dynamic method dispatch and is a key aspect of runtime polymorphism.\n\n### Practice Exercise:\n\nCreate a `Cat` class that extends `Animal` and override the `makeSound()` method to print \"The cat meows\". Then create an array of `Animal` objects containing both `Dog` and `Cat` instances, and call `makeSound()` on each to observe dynamic method dispatch.\n\n### Common Mistakes to Avoid:\n\n1. Changing the method signature (creating an overloaded method instead of overriding)\n2. Forgetting the `@Override` annotation (not a syntax error, but a best practice)\n3. Making the access modifier more restrictive\n4. Trying to override `final` methods (not allowed in Java)"
    },
    "super_keyword": {
      "title": "The super Keyword",
      "keywords": ["super", "super()", "super.", "superclass constructor"],
      "content": "## The super Keyword in Java\n\n### Definition:\nThe `super` keyword in Java is used to refer to the superclass (parent class).\n\n### Two Main Uses:\n\n1. **Calling superclass constructors**: `super()` or `super(parameters)`\n2. **Accessing superclass methods and fields**: `super.methodName()` or `super.fieldName`\n\n### Calling Superclass Constructors:\n\nWhen creating an object of a subclass, a constructor of the superclass is called to initialize the inherited fields.\n\n```java\n// Superclass\npublic class Animal {\n    private String name;\n    \n    public Animal(String name) {\n        this.name = name;\n    }\n}\n\n// Subclass\npublic class Dog extends Animal {\n    private String breed;\n    \n    public Dog(String name, String breed) {\n        super(name);  // Call the superclass constructor\n        this.breed = breed;\n    }\n}\n```\n\n### Important Rules for super() Constructor Calls:\n\n* **Must be first statement**: The call to the superclass constructor must be the first statement in the subclass constructor\n\n* **Implicit call**: If you don't explicitly call a superclass constructor, Java automatically inserts a call to the no-argument superclass constructor (`super()`)\n\n* **Required explicit call**: If the superclass doesn't have a no-argument constructor, you must explicitly call another constructor\n\n* **Cannot skip**: A subclass constructor cannot skip calling a superclass constructor - either implicit or explicit call must occur\n\n### Accessing Superclass Methods and Fields:\n\nThe `super` keyword can also be used to access methods or fields in the superclass, especially when they are overridden in the subclass.\n\n```java\n// Superclass\npublic class Animal {\n    public void eat() {\n        System.out.println(\"Animal is eating\");\n    }\n}\n\n// Subclass\npublic class Dog extends Animal {\n    @Override\n    public void eat() {\n        super.eat();  // Call the superclass method\n        System.out.println(\"Dog is eating a bone\");\n    }\n}\n```\n\n### Benefits of Using super:\n\n* **Extending functionality**: Allows a subclass to extend the functionality of a superclass method rather than completely replacing it\n\n* **Accessing hidden members**: Provides access to superclass members that are hidden by subclass members with the same name\n\n* **Maintaining inheritance chain**: Ensures proper initialization of inherited state from all ancestor classes\n\n### Practice Exercise:\n\nCreate a `Vehicle` class with a `startEngine()` method that prints \"Engine starting\". Then create a `Car` class that extends `Vehicle` and overrides `startEngine()` to first call the superclass method and then print \"Car engine running\". Test your implementation by creating a Car object and calling its `startEngine()` method.\n\n### Common Mistakes to Avoid:\n\n1. Trying to use `super()` anywhere other than as the first statement in a constructor\n2. Forgetting to call `super()` when the superclass doesn't have a no-argument constructor\n3. Using `super` in a static context (not allowed in Java)\n4. Confusing `super` with `this` keyword"
    }
  }
}
